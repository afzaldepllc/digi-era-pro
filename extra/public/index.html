<!DOCTYPE html>
<html>

<head>
    <title>WebRTC Voice Call</title>
</head>

<body>
    <h2>WebRTC Voice Call (Same Wi-Fi)</h2>
    <button id="callBtn">ðŸ“ž Call</button>
    <p id="status">Waiting...</p>
    <audio id="remoteAudio" autoplay></audio>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io()
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                {
                    urls: "turn:relay.metered.ca:80",
                    username: "openai",
                    credential: "openai"
                }
            ]
        })

        pc.oniceconnectionstatechange = () => {
            console.log("ICE state:", pc.iceConnectionState)
        }

        const callBtn = document.getElementById("callBtn")
        const remoteAudio = document.getElementById("remoteAudio")
        const status = document.getElementById("status")

        // Capture local mic
        let localStream
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
                localStream = stream
                stream.getTracks().forEach(track => pc.addTrack(track, stream))
                status.textContent = "Microphone ready. Click 'Call' to start."
            })
            .catch(err => {
                status.textContent = "Mic access denied: " + err.message
            })

        // Play incoming audio
        pc.ontrack = e => {
            remoteAudio.srcObject = e.streams[0]
            status.textContent = "Connected!"
        }

        // ICE candidates
        pc.onicecandidate = e => {
            if (e.candidate) socket.emit("candidate", e.candidate)
        }

        // Handle incoming signaling
        socket.on("offer", async offer => {
            await pc.setRemoteDescription(new RTCSessionDescription(offer))
            const answer = await pc.createAnswer()
            await pc.setLocalDescription(answer)
            socket.emit("answer", answer)
            status.textContent = "Answer sent."
        })

        socket.on("answer", async answer => {
            await pc.setRemoteDescription(new RTCSessionDescription(answer))
            status.textContent = "In call."
        })

        socket.on("candidate", async candidate => {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(candidate))
            } catch (err) {
                console.error("Error adding candidate:", err)
            }
        })

        // Button to initiate call
        callBtn.onclick = async () => {
            if (!localStream) return alert("Microphone not ready yet.")
            const offer = await pc.createOffer()
            await pc.setLocalDescription(offer)
            socket.emit("offer", offer)
            status.textContent = "Calling..."
        }
    </script>
</body>

</html>
<!DOCTYPE html>
<html>

<head>
    <title>WebRTC Voice Call</title>
</head>

<body>
    <h2>WebRTC Voice Call (Same Wi-Fi)</h2>
    <button id="callBtn">ðŸ“ž Call</button>
    <p id="status">Waiting...</p>
    <audio id="remoteAudio" autoplay></audio>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io()
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                {
                    urls: "turn:relay.metered.ca:80",
                    username: "openai",
                    credential: "openai"
                }
            ]
        })

        pc.oniceconnectionstatechange = () => {
            console.log("ICE state:", pc.iceConnectionState)
        }

        const callBtn = document.getElementById("callBtn")
        const remoteAudio = document.getElementById("remoteAudio")
        const status = document.getElementById("status")

        // Capture local mic
        let localStream
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
                localStream = stream
                stream.getTracks().forEach(track => pc.addTrack(track, stream))
                status.textContent = "Microphone ready. Click 'Call' to start."
            })
            .catch(err => {
                status.textContent = "Mic access denied: " + err.message
            })

        // Play incoming audio
        pc.ontrack = e => {
            remoteAudio.srcObject = e.streams[0]
            status.textContent = "Connected!"
        }

        // ICE candidates
        pc.onicecandidate = e => {
            if (e.candidate) socket.emit("candidate", e.candidate)
        }

        // Handle incoming signaling
        socket.on("offer", async offer => {
            await pc.setRemoteDescription(new RTCSessionDescription(offer))
            const answer = await pc.createAnswer()
            await pc.setLocalDescription(answer)
            socket.emit("answer", answer)
            status.textContent = "Answer sent."
        })

        socket.on("answer", async answer => {
            await pc.setRemoteDescription(new RTCSessionDescription(answer))
            status.textContent = "In call."
        })

        socket.on("candidate", async candidate => {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(candidate))
            } catch (err) {
                console.error("Error adding candidate:", err)
            }
        })

        // Button to initiate call
        callBtn.onclick = async () => {
            if (!localStream) return alert("Microphone not ready yet.")
            const offer = await pc.createOffer()
            await pc.setLocalDescription(offer)
            socket.emit("offer", offer)
            status.textContent = "Calling..."
        }
    </script>
</body>

</html>